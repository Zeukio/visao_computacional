
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Panoramic</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-04-22"><meta name="DC.source" content="Panoramic.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">PANORAMIC</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> Im_panoramic = Panoramic( path, varargin )
</pre><h2>PANORAMIC<a name="2"></a></h2><p>Panoramic esta fun&ccedil;&atilde;o retorna a uma imagem panoramica formada pelas imagens do dataset que est&atilde;o na pasta do <i>path</i>.</p><p><b>As Imagens devem estar em sequncia para que a fun&ccedil;&atilde;o funcione corretamente</b></p><p><tt>Im = Panoramic( path )</tt></p><p>onde <tt>Im  = imagem</tt> <tt>path = string do diret&oacute;rio do data set</tt></p><p>pode se alterar o tamanho processado da imagem usando:</p><p><tt>Im = Panoramic( path, 'size', size_vec )</tt></p><p>Default [480 640]</p><p>pode se mostrar parte do processamento na tela usando:</p><p><tt>Im = Panoramic( path, 'display')</tt></p><p>Default false</p><p>Mudar o numero de matches:</p><p><tt>Im = Panoramic( path, 'matches', num_matches)</tt></p><p>Default 300</p><p>Mudar o par&acirc;metro do filtro threshold usado na para criar a matriz de homografia</p><p><tt>Im = Panoramic( path, 'threshold', num_threshold)</tt></p><p>Default 0.3</p><p>Centralizar o panorama</p><p><tt>Im = Panoramic( path, 'center')</tt></p><p>Default false</p><p>Tamb&eacute;m pode se usar mais de um comando (<b>n&atilde;o importa a ordem</b>);</p><p><tt>Im = Panoramic( path,'display','size', size_vec,'threshold', num_threshold, 'matches', num_maches)</tt></p><p>Valores default</p><pre class="codeinput">num_threshold = 0.3;
num_matches = 300;
imreadsize = [480 640];
dispim = false;
center = false;
</pre><p>Novos valores</p><pre class="codeinput">comand = {};
</pre><p>Manipular as diferentes possiveis entradas da fun&ccedil;&atilde;o</p><pre class="codeinput"><span class="keyword">if</span> nargin &gt; 1

    <span class="keyword">if</span> isa(varargin{1},<span class="string">'cell'</span>)

        comand = varargin{1};
        [~, buf] = size(varargin{1});
    <span class="keyword">else</span>

        [~, buf] = size(varargin);
        <span class="keyword">for</span> i = 1:buf

            comand{i} =  varargin{i};
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">for</span> i = 1 : buf
        <span class="keyword">if</span> ischar(comand{i})
            <span class="keyword">if</span> isequal(comand{i},<span class="string">'display'</span>)

                <span class="comment">%se display</span>
                dispim = true;
            <span class="keyword">elseif</span> isequal(comand{i},<span class="string">'size'</span>)

                <span class="comment">% se Size</span>
                imreadsize = comand{i+1};
                i = i+1;
            <span class="keyword">elseif</span> isequal(comand{i},<span class="string">'matches'</span>)

                <span class="comment">% se Matches</span>
                num_matches = comand{i+1};
                i = i+1;
            <span class="keyword">elseif</span> isequal(comand{i},<span class="string">'threshold'</span>)

                <span class="comment">% se Threshold</span>
                num_threshold = comand{i+1};
                i = i+1;
            <span class="keyword">elseif</span> isequal(comand{i},<span class="string">'center'</span>)

                <span class="comment">% se Center</span>
                center = true;
            <span class="keyword">else</span>
                <span class="comment">% Erro caso os comandos forem inv&aacute;lidos</span>
                error(<span class="string">'Invalid Input'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>Verifica&ccedil;&atilde;o do Caminho</p><pre class="codeinput"><span class="keyword">try</span>

    buildingScene = imageSet(path);
    <span class="keyword">if</span> dispim

        disp(<span class="string">'reading images'</span>)
        montage(buildingScene.ImageLocation);
    <span class="keyword">end</span>

<span class="keyword">catch</span> ME

    disp(<span class="string">'Wrong path'</span>);
    rethrow(ME)
<span class="keyword">end</span>
</pre><pre class="codeoutput">reading images
Warning: Image is too big to fit on screen;
displaying at 33% 
</pre><img vspace="5" hspace="5" src="Panoramic_01.png" alt=""> <p>Leitura da Imagem 1 do Data set</p><pre class="codeinput">I{1} = imresize(iread(buildingScene.ImageLocation{1}, <span class="string">'double'</span>),imreadsize );
<span class="comment">% Busca das features de superficie da imagem 1</span>
Sf = isurf(I);
<span class="comment">% Matriz de homagrafia da imagem 1 &eacute; identidade j&aacute; que ela n&atilde;o sera distorcida</span>
H{1} = eye(3);
<span class="comment">% Matriz de homagrafia acumulada inicial</span>
tforms{1} = eye(3);
<span class="comment">% Imagem 1 distorcida ser&aacute; igual a imagem 1 sem a distor&ccedil;&atilde;o, visto que ela</span>
<span class="comment">% sera a base para todas as outras</span>
newim{1} = I{1};
<span class="comment">% Pontos de offset da imagem 1 na figura final</span>
points{1} = [0 0];
</pre><pre class="codeoutput">extracting SIFT features for 1 greyscale images
1075 corners found (0.3%),  1075 corner features saved
.
</pre><p>Procura de features e a rela&ccedil;&atilde;o entre as imagens</p><pre class="codeinput"><span class="keyword">if</span> dispim

    disp(<span class="string">'finding features and matches'</span>);
<span class="keyword">end</span>

<span class="keyword">for</span> i = 2:buildingScene.Count

    <span class="comment">% Atualiza as variaveis para o proximo loop</span>
    Iant = I{i-1};
    Sfant = Sf{i-1};
    <span class="comment">% Abrir Imagem n</span>
    I{i} = imresize(iread(buildingScene.ImageLocation{i}, <span class="string">'double'</span>), [480 640]);
    <span class="comment">% Procurar fetures na Imagem n</span>
    Sf{i} = isurf(I{i});
    <span class="comment">% Faz o match entre as features da imagem anterior, e a atual -&gt; I(n)</span>
    m{i} = Sf{i}.match(Sfant, <span class="string">'top'</span>, num_matches);
    <span class="comment">% Calcula a matriz de homografia etre os pontos das duas imagens</span>
    [H{i} val{i} val2{i}] = ransac(@homography,[m{i}.xy_], num_threshold);
<span class="keyword">end</span>
</pre><pre class="codeoutput">finding features and matches
1127 corners found (0.4%),  1127 corner features saved
Warning: ransac reached the maximum number
of 2000 trials; probability of including an
outlier is 0.859118
try running ransac again 

1116 corners found (0.4%),  1116 corner features saved

1174 corners found (0.4%),  1174 corner features saved
Warning: ransac reached the maximum number
of 2000 trials; probability of including an
outlier is 0.999407
try running ransac again 

1037 corners found (0.3%),  1037 corner features saved
Warning: ransac reached the maximum number
of 2000 trials; probability of including an
outlier is 0.987572
try running ransac again 

</pre><pre class="codeinput"><span class="keyword">if</span> center

    <span class="comment">%imagem central</span>
    nuim = buildingScene.Count/2;
    <span class="keyword">if</span> nuim ~= round(nuim)

        nuim = round(nuim);
    <span class="keyword">end</span>

    <span class="comment">% Arrumando a ordem das matrizes de homografia</span>
    H(1:nuim-1) = H(2:nuim);
    H{nuim} = eye(3);
    newim{nuim} = I{nuim};
    tforms{nuim} = eye(3);

    <span class="comment">% Calculo da matriz de homografia acumulada pra esquerda</span>
    <span class="keyword">for</span> i = nuim:-1:2

        tforms{i-1} = H{i-1}^-1*tforms{i};
    <span class="keyword">end</span>

    <span class="comment">% Calculo da matriz de homografia acumulada pra direita</span>
    <span class="keyword">for</span> i =  nuim+1:buildingScene.Count

        tforms{i} = tforms{i-1}*H{i};
    <span class="keyword">end</span>
<span class="keyword">else</span>

    <span class="keyword">for</span> i = 2:buildingScene.Count

        <span class="comment">% Atualiza a Matriz de homografia acumulada</span>
        tforms{i} = tforms{i-1} * H{i};
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Transformando as imagens</span>
<span class="keyword">for</span> i = 1:buildingScene.Count
    <span class="comment">% Faz a homografia da imagem I(n) -&gt; newim(n)</span>
    [bufim points{i}] = homwarp(tforms{i},I{i},<span class="string">'full'</span>);
    <span class="comment">% Tira NaN das imagens distrocidas</span>
    bufim(isnan(bufim)) = 0;
    newim{i} = bufim;
<span class="keyword">end</span>

<span class="keyword">if</span>  dispim

    <span class="comment">% Display das imagens finais</span>
    figure, idisp(newim);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Panoramic_02.png" alt=""> <p>Setando o Tamanho da imagem final</p><pre class="codeinput"><span class="comment">%</span>
[u1,v1,~] = size(I{end});
<span class="comment">%</span>
[y,x,~] = cellfun(@size, newim);
<span class="comment">%</span>
temp = cell2mat(points);

<span class="comment">% Definir o ponto inicial do panorama</span>
<span class="keyword">if</span> center

    <span class="comment">%</span>
    off = [ (sum(x - temp(1:2:end))/2) - v1/2, max(y) - u1];
    <span class="comment">%</span>
    Panoramic = zeros( max(y) + max(y) - u1 , sum(x - temp(1:2:end)));
<span class="keyword">else</span>

    <span class="comment">%</span>
    off = [1, (max(y) - u1)];
    <span class="comment">%</span>
    Panoramic = zeros( max(y) + (max(y) - u1), sum(x - temp(1:2:end)));
<span class="keyword">end</span>
</pre><p>Montagem do panorana</p><pre class="codeinput"><span class="keyword">for</span> i = 1:buildingScene.Count

    <span class="comment">%</span>
    mask{i} = homwarp(tforms{i},ones(u1, v1),<span class="string">'full'</span>);
    <span class="comment">%</span>
    mask{i} = mask{i} &gt;= 1;
    <span class="comment">%</span>
    wmask{i} = 1 - mask{i};
<span class="keyword">end</span>

<span class="keyword">for</span> i = 2:buildingScene.Count

    <span class="comment">%</span>
    Panoramic = ipaste(Panoramic, newim{i}, points{i}+off, <span class="string">'add'</span>);
    <span class="comment">%</span>
    Panoramic = ipaste(Panoramic, mask{i-1}, points{i-1}+off, <span class="string">'add'</span>);
    <span class="comment">%</span>
    Panoramic = adjust(Panoramic);
    <span class="comment">%</span>
    Panoramic = ipaste(Panoramic, newim{i-1}, points{i-1}+off, <span class="string">'add'</span>);
<span class="keyword">end</span>

<span class="keyword">if</span> dispim

    figure, idisp(Panoramic);
<span class="keyword">end</span>

Im_panoramic = Panoramic;
</pre><img vspace="5" hspace="5" src="Panoramic_03.png" alt=""> <p>&Eacute; temb&eacute;m possivel fazer o panorama centralizado, por&eacute;m ele n&atilde;o encaixa as imagens t&atilde;o bem quanto o n&atilde;o centralizado</p><p><img vspace="5" hspace="5" src="Panoramic_center.PNG" alt=""> </p><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####


function Im_panoramic = Panoramic( path, varargin )
%% PANORAMIC
% Panoramic esta função retorna a uma imagem panoramica formada pelas
% imagens do dataset que estão na pasta do _path_.
%
% *As Imagens devem estar em sequncia para que a função funcione corretamente*
%
% |Im = Panoramic( path )|
%
% onde
% |Im  = imagem|
% |path = string do diretório do data set|
%
% pode se alterar o tamanho processado da imagem usando:
%
% |Im = Panoramic( path, 'size', size_vec )|
%
% Default [480 640]
%
% pode se mostrar parte do processamento na tela usando:
%
% |Im = Panoramic( path, 'display')|
%
% Default false
%
% Mudar o numero de matches:
%
% |Im = Panoramic( path, 'matches', num_matches)|
%
% Default 300
%
% Mudar o parâmetro do filtro threshold usado na para criar a matriz de homografia
%
% |Im = Panoramic( path, 'threshold', num_threshold)|
%
% Default 0.3
%
% Centralizar o panorama 
%
% |Im = Panoramic( path, 'center')|
%
% Default false
%
% Também pode se usar mais de um comando (*não importa a ordem*);
%
% |Im = Panoramic( path,'display','size', size_vec,'threshold', num_threshold, 'matches', num_maches)|
%


%%
% Valores default
num_threshold = 0.3;
num_matches = 300;
imreadsize = [480 640];
dispim = false;
center = false; 

%%
% Novos valores
comand = {};

%%
% Manipular as diferentes possiveis entradas da função
if nargin > 1
    
    if isa(varargin{1},'cell')
        
        comand = varargin{1};
        [~, buf] = size(varargin{1});
    else
        
        [~, buf] = size(varargin);
        for i = 1:buf
            
            comand{i} =  varargin{i};
        end
    end
    
    for i = 1 : buf
        if ischar(comand{i})
            if isequal(comand{i},'display')
                
                %se display
                dispim = true;
            elseif isequal(comand{i},'size')
                
                % se Size
                imreadsize = comand{i+1};
                i = i+1;
            elseif isequal(comand{i},'matches')
                
                % se Matches
                num_matches = comand{i+1};
                i = i+1;
            elseif isequal(comand{i},'threshold')
                
                % se Threshold
                num_threshold = comand{i+1};
                i = i+1;
            elseif isequal(comand{i},'center')
                
                % se Center
                center = true;
            else
                % Erro caso os comandos forem inválidos
                error('Invalid Input');
            end
        end
    end
end

%% 
% Verificação do Caminho
try
    
    buildingScene = imageSet(path);
    if dispim
        
        disp('reading images')
        montage(buildingScene.ImageLocation);
    end
    
catch ME
    
    disp('Wrong path');
    rethrow(ME)
end

%%
% Leitura da Imagem 1 do Data set

I{1} = imresize(iread(buildingScene.ImageLocation{1}, 'double'),imreadsize );
% Busca das features de superficie da imagem 1
Sf = isurf(I);
% Matriz de homagrafia da imagem 1 é identidade já que ela não sera distorcida
H{1} = eye(3);
% Matriz de homagrafia acumulada inicial
tforms{1} = eye(3);
% Imagem 1 distorcida será igual a imagem 1 sem a distorção, visto que ela
% sera a base para todas as outras
newim{1} = I{1};
% Pontos de offset da imagem 1 na figura final
points{1} = [0 0];

%%
% Procura de features e a relação entre as imagens
if dispim
    
    disp('finding features and matches');
end

for i = 2:buildingScene.Count
    
    % Atualiza as variaveis para o proximo loop
    Iant = I{i-1};
    Sfant = Sf{i-1};
    % Abrir Imagem n
    I{i} = imresize(iread(buildingScene.ImageLocation{i}, 'double'), [480 640]);
    % Procurar fetures na Imagem n
    Sf{i} = isurf(I{i});
    % Faz o match entre as features da imagem anterior, e a atual -> I(n)
    m{i} = Sf{i}.match(Sfant, 'top', num_matches);
    % Calcula a matriz de homografia etre os pontos das duas imagens
    [H{i} val{i} val2{i}] = ransac(@homography,[m{i}.xy_], num_threshold);
end

%%



if center
    
    %imagem central
    nuim = buildingScene.Count/2;
    if nuim ~= round(nuim)
        
        nuim = round(nuim);
    end
    
    % Arrumando a ordem das matrizes de homografia
    H(1:nuim-1) = H(2:nuim);
    H{nuim} = eye(3);    
    newim{nuim} = I{nuim};
    tforms{nuim} = eye(3);
    
    % Calculo da matriz de homografia acumulada pra esquerda
    for i = nuim:-1:2
        
        tforms{i-1} = H{i-1}^-1*tforms{i};
    end   
    
    % Calculo da matriz de homografia acumulada pra direita
    for i =  nuim+1:buildingScene.Count
        
        tforms{i} = tforms{i-1}*H{i};
    end 
else
    
    for i = 2:buildingScene.Count
        
        % Atualiza a Matriz de homografia acumulada
        tforms{i} = tforms{i-1} * H{i};        
    end
end

% Transformando as imagens
for i = 1:buildingScene.Count
    % Faz a homografia da imagem I(n) -> newim(n)
    [bufim points{i}] = homwarp(tforms{i},I{i},'full');
    % Tira NaN das imagens distrocidas
    bufim(isnan(bufim)) = 0;
    newim{i} = bufim;
end

if  dispim
    
    % Display das imagens finais
    figure, idisp(newim);
end
%%
% Setando o Tamanho da imagem final

%
[u1,v1,~] = size(I{end});
%
[y,x,~] = cellfun(@size, newim);
%
temp = cell2mat(points);

% Definir o ponto inicial do panorama
if center
    
    %
    off = [ (sum(x - temp(1:2:end))/2) - v1/2, max(y) - u1];    
    %
    Panoramic = zeros( max(y) + max(y) - u1 , sum(x - temp(1:2:end)));
else
    
    %
    off = [1, (max(y) - u1)];
    %
    Panoramic = zeros( max(y) + (max(y) - u1), sum(x - temp(1:2:end)));
end
%%
% Montagem do panorana

for i = 1:buildingScene.Count
    
    %
    mask{i} = homwarp(tforms{i},ones(u1, v1),'full');
    %
    mask{i} = mask{i} >= 1;
    %
    wmask{i} = 1 - mask{i};
end

for i = 2:buildingScene.Count
    
    %
    Panoramic = ipaste(Panoramic, newim{i}, points{i}+off, 'add');
    %
    Panoramic = ipaste(Panoramic, mask{i-1}, points{i-1}+off, 'add');
    %
    Panoramic = adjust(Panoramic);
    %
    Panoramic = ipaste(Panoramic, newim{i-1}, points{i-1}+off, 'add');
end

if dispim
    
    figure, idisp(Panoramic);
end

Im_panoramic = Panoramic;

%%
% É tembém possivel fazer o panorama centralizado, porém ele não encaixa as
% imagens tão bem quanto o não centralizado 
%
% <<Panoramic_center.PNG>>
% 
%


end


##### SOURCE END #####
--></body></html>